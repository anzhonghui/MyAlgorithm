package com.qk.myleetcode.range_51_100.medium;

import org.junit.Test;

public class UniqueBinarySearchTrees {

	/**
	 * @Description:
	 * @Example:
	 * @Pragramme:
	 */
	@Test
	public void MyTest() {
		System.out.println(numTrees(3));
	}

	/*
	 * 这个问题可以用动态规划的方法来解决。我将在下面解释直觉和公式。
	 * 给定一个序列1…n，为了从序列中构造一个二叉搜索树（bst），我们可以枚举序列中的每个数字i，并使用该数字作为根，自然地，其左侧的子序列1…（i-1）
	 * 将位于根的左分支，同样，右子序列（i+1）…n将位于根的右分支。然后我们可以递归地从子序列构造子树。通过上述方法，我们可以确保我们构建的BST都是唯一的，
	 * 因为它们具有唯一的根。
	 * 问题是要计算唯一BST的数目。为此，我们需要定义两个函数：
	 * G（n）：长度为n的序列的唯一bst的数目。
	 * f（i，n），1<=i<=n：唯一的bst的个数，其中i是bst的根，序列从1到n。
	 * 可以看到，g（n）是我们为了解决这个问题需要计算的实际函数。g（n）可以从f（i，n）中得到，f（i，n）在结尾处递归地引用g（n）。
	 * 首先，给定上述定义，我们可以看到唯一bst g（n）的总数是使用每个数字i作为根的bst f（i）的总和。
	 * 即
	 * g（n）=f（1，n）+f（2，n）++F（n，n）。
	 * 尤其是在底层，只有一个组合可以用长度为1（只有一个根）或0（空树）的序列来构造BST。
	 * 即
	 * g（0）＝1，G（1）＝1。
	 * 给定序列1…n，我们从序列中选择一个数字i作为根，那么具有指定根f（i）的唯一bst的数目是其左、右子树bst数目的笛卡尔积。例如，F（3，7）：
	 * 以数字3为根的唯一BST树的数目。要从整个序列[1，2，3，4，5，6，7]中构造一个唯一的bst，以3为根，也就是说，我们需要从其左子序列[1，2]
	 * 和右子序列[4，5，6，7]中构造一个唯一的bst，然后将它们组合在一起（即笛卡尔积）。比较棘手的是，我们可以把序列[1,2]中唯一BST的个数看作G（2
	 * ），把序列[4,5,6,7]中唯一BST的个数看作G（4）。因此，f（3,7）=g（2）*g（4）。【因为两边的情况可以对调】
	 * 即
	 * f（i，n）=g（i-1）*g（n-i）1<=i<=n
	 * 结合以上两个公式，得到了G（N）的递推公式。即
	 * g（n）=g（0）*g（n-1）+g（1）*g（n-2）+…+g（n-1）*g（0）
	 * 在计算中，我们需要从较低的数字开始，因为g（n）的值取决于g（0）…g（n-1）的值。
	 * 通过上面的解释和公式，这里是爪哇的实现。
	 */
	public int numTrees(int n) {
		int[] G = new int[n + 1];
		G[0] = G[1] = 1;

		for (int i = 2; i <= n; ++i) {
			for (int j = 1; j <= i; ++j) {
				G[i] += G[j - 1] * G[i - j];
			}
		}

		return G[n];
	}
}
